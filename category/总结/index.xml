<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>总结 | Donald Blog</title>
    <link>https://kurimi1.github.io/category/%E6%80%BB%E7%BB%93/</link>
      <atom:link href="https://kurimi1.github.io/category/%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml" />
    <description>总结</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><lastBuildDate>Wed, 08 Jun 2022 03:44:18 +0000</lastBuildDate>
    <image>
      <url>https://kurimi1.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url>
      <title>总结</title>
      <link>https://kurimi1.github.io/category/%E6%80%BB%E7%BB%93/</link>
    </image>
    
    <item>
      <title>Pack Backend Frontend in a Docker</title>
      <link>https://kurimi1.github.io/post/pack-backend-frontend-in-a-docker/</link>
      <pubDate>Wed, 08 Jun 2022 03:44:18 +0000</pubDate>
      <guid>https://kurimi1.github.io/post/pack-backend-frontend-in-a-docker/</guid>
      <description>&lt;p&gt;前后端分离是主流，go也可以通过template进行服务器渲染前端，但采用主流的前端框架vue，react，flutter等有丰富的UI，且前端可以直接做CDN等优势。本文总结当一个小项目前后端分离时仅通过一个容器启动的方法。&lt;/p&gt;
&lt;h3 id=&#34;通过nginx部署前端反代到后端api&#34;&gt;通过nginx部署前端，反代到后端api&lt;/h3&gt;
&lt;p&gt;这种方式相当于一个容器里起了nginx和后端2个服务。后端需要监听端口，nginx通过访问本地端口来连接后端。&lt;/p&gt;
&lt;h3 id=&#34;后端路由到前端的静态资源前端实现反代调用后端api&#34;&gt;后端路由到前端的静态资源，前端实现反代调用后端api&lt;/h3&gt;
&lt;p&gt;后端路由设置静态文件目录，根目录/301到静态目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Static(&amp;quot;/static&amp;quot;, &amp;quot;./static&amp;quot;)
r.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) {
  c.Redirect(http.StatusMovedPermanently, &amp;quot;/static/&amp;quot;)
  return
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前端axios设置base_url&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL, // api base_url
  timeout: 6000 // 请求超时时间
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;将前端静态资源嵌入到go二进制当中&#34;&gt;将前端静态资源嵌入到go二进制当中&lt;/h3&gt;
&lt;p&gt;这样做不需要复制静态文件，直接运行二进制即可。&lt;code&gt;阅读drone源码发现的&lt;/code&gt;，前端是单独放在另一个仓库中的&lt;a href=&#34;https://github.com/drone/drone-ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/drone/drone-ui&lt;/a&gt;，这里的dist目录里面有两个文件dist.go和dist_gen.go。
其中dist.go的“代码”只有短短的两行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package dist

//go:generate togo http -package dist -output dist_gen.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里就要介绍一下go generate命令了。&lt;/p&gt;
&lt;h4 id=&#34;go-generate是什么&#34;&gt;go generate是什么？&lt;/h4&gt;
&lt;p&gt;go generate 是自 Go 1.4 版本后加入的一个命令，当运行此命令时，它将扫描与当前包相关的源代码文件，找出文件中所有包含//go:generate的特殊注释，并将该注释后面的内容当做 shell 执行。
虽说是可以执行任意命令，但它往往被用作自动生成代码。为了避免自动生成的代码之后被人为修改，往往还会在生成的代码前面加上// Code generated by xxxx; DO NOT EDIT.这样的提示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意，//go:generate并不会在go build或go run时执行。只能单独使用go generate执行。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实 Go 里面还有很多类似//go:xxx这样的注释。像//go:noinline //go:nosplit //go:norace 这些，大多都是控制 Go 编译器的一些命令。&lt;/p&gt;
&lt;p&gt;回到 Drone，这里的go:generate togo http -package dist -output dist_gen.go后面的命令是使用了 Drone 作者自己开发的一个小工具togo。&amp;laquo;&lt;a href=&#34;https://github.com/bradrydzewski/tog%3e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/bradrydzewski/tog&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它可以将 HTML、SQL、JSON 等静态文件转换成 Go 文件。使我们可以直接在项目的 Go 源码中调用这些文件。togo就是个 CLI 程序，源码不多；大概看了下，基本流程就是将静态文件的内容进行简单的处理后（比如转义掉反引号）然后使用 Go 自带的模板语言template包将静态文件内容以及文件信息插入到事先写好的 Go 代码模板中。&lt;/p&gt;
&lt;h4 id=&#34;将dist_gengo引入到项目中&#34;&gt;将dist_gen.go引入到项目中&lt;/h4&gt;
&lt;p&gt;Build the app and run go generate&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;npm run build
# change to the dist directory
cd dist
# run go generate
GO111MODULE=off go generate ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will update the &lt;code&gt;dist/dist_gen.go&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;既分离了前后端项目的源代码，又通过包的方式使得前端和后端能很好的结合，妙啊！&lt;/p&gt;
&lt;p&gt;同样是&lt;code&gt;后端路由输出静态文件&lt;/code&gt;，只不过静态文件在go代码中，一起编译成二进制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func HandleIndex(host string, session core.Session, license core.LicenseService) http.HandlerFunc {
	return func(rw http.ResponseWriter, r *http.Request) {
    user, _ := session.Get(r)
		if user == nil &amp;amp;&amp;amp; r.URL.Path == &amp;quot;/&amp;quot; {
			http.Redirect(rw, r, &amp;quot;/welcome&amp;quot;, 303)
			return
		}

		out := dist.MustLookup(&amp;quot;/index.html&amp;quot;)
		ctx := r.Context()

		if ok, _ := license.Exceeded(ctx); ok {
			out = bytes.Replace(out, head, exceeded, -1)
		} else if license.Expired(ctx) {
			out = bytes.Replace(out, head, expired, -1)
		}
		rw.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html; charset=UTF-8&amp;quot;)
		rw.Write(out)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html会引用static下的js，css等因此要设置路由链接嵌入的静态文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	h := http.FileServer(dist.New())
	h = setupCache(h)
	r.Handle(&amp;quot;/favicon.png&amp;quot;, h)
	r.Handle(&amp;quot;/manifest.json&amp;quot;, h)
	r.Handle(&amp;quot;/asset-manifest.json&amp;quot;, h)
	r.Handle(&amp;quot;/static/*filepath&amp;quot;, h)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里再提一下上面两个命令中的./..这个用法。它可以遍历包括当前文件夹在内的所有子文件夹。
起初看到这个还以为是操作系统的特性，但谷歌搜了半天没搜到。最后还是在 Go 的源码文档里看到了对此的解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &amp;ldquo;go list&amp;rdquo; subcommand lists the import paths corresponding to its arguments, and the pattern &amp;ldquo;./&amp;hellip;&amp;rdquo; means start in the current directory (&amp;quot;./&amp;quot;) and find all packages below that directory (&amp;quot;&amp;hellip;&amp;quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;最后提一下将静态文件嵌入go二进制的工具很多&#34;&gt;最后提一下将静态文件嵌入go二进制的工具很多&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;togo已经不再维护&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一些开源的项目很久以前就开始做这方面的工作，比如gobuffalo/packr、markbates/pkger、rakyll/statik、knadh/stuffbin等等，但是不管怎么说这些都是第三方提供的功能，如果Go官方能内建支持就好了。2019末一个提案被提出issue#35950,期望Go官方编译器支持嵌入静态文件。后来Russ Cox专门写了一个设计文档Go command support for embedded static assets, 并最终实现了它。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在k8s中部署的系统获取用户ip</title>
      <link>https://kurimi1.github.io/post/k8s-get-userip/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://kurimi1.github.io/post/k8s-get-userip/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;k8s Cluster模式 访问任何节点ip自带路由跳转(反向代理？)，因此后端获取到的是转换过一次的ip，而不是用户真实ip&lt;/p&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;设置：externalTrafficPolicy: Local&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rook-ceph 踩坑</title>
      <link>https://kurimi1.github.io/post/rook-ceph/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://kurimi1.github.io/post/rook-ceph/</guid>
      <description>&lt;h2 id=&#34;k8s-安装rook-ceph&#34;&gt;k8s 安装rook-ceph&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://rook.io/docs/rook/v1.7/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://rook.io/docs/rook/v1.7/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;添加新磁盘&#34;&gt;添加新磁盘&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#扫描 SCSI总线并添加 SCSI 设备
for host in $(ls /sys/class/scsi_host) ; do echo &amp;quot;- - -&amp;quot; &amp;gt; /sys/class/scsi_host/$host/scan; done

#重新扫描 SCSI 总线
for scsi_device in $(ls /sys/class/scsi_device/); do echo 1 &amp;gt; /sys/class/scsi_device/$scsi_device/device/rescan; done

#查看已添加的磁盘，能够看到sdb说明添加成功
lsblk
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;清理集群&#34;&gt;清理集群&lt;/h2&gt;
&lt;p&gt;关闭pods，才能pvc才能被删除&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rook.io/docs/rook/v1.7/ceph-teardown.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://rook.io/docs/rook/v1.7/ceph-teardown.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;节点磁盘格式化&#34;&gt;节点磁盘格式化&lt;/h2&gt;
&lt;p&gt;最好每个磁盘都格式化一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash
DISK=&amp;quot;/dev/sdd&amp;quot;

# Zap the disk to a fresh, usable state (zap-all is important, b/c MBR has to be clean)

# You will have to run this step for all disks.
sgdisk --zap-all $DISK

# Clean hdds with dd
dd if=/dev/zero of=&amp;quot;$DISK&amp;quot; bs=1M count=100 oflag=direct,dsync

# Clean disks such as ssd with blkdiscard instead of dd
blkdiscard $DISK

# These steps only have to be run once on each node
# If rook sets up osds using ceph-volume, teardown leaves some devices mapped that lock the disks.
ls /dev/mapper/ceph-* | xargs -I% -- dmsetup remove %

# ceph-volume setup can leave ceph-&amp;lt;UUID&amp;gt; directories in /dev and /dev/mapper (unnecessary clutter)
rm -rf /dev/ceph-*
rm -rf /dev/mapper/ceph--*

# Inform the OS of partition table changes
partprobe $DISK

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;
&lt;p&gt;删除Ceph集群后，在之前部署Ceph组件节点的/var/lib/rook/目录，会遗留下Ceph集群的配置信息。
若之后再部署新的Ceph集群，先把之前Ceph集群的这些信息删除，不然启动monitor会失败；&lt;/p&gt;
&lt;h3 id=&#34;坑点&#34;&gt;坑点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;删除前必须先删除所有申请的资源&lt;/li&gt;
&lt;li&gt;记得删除申请的文件系统！！！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;kubectl api-resources &amp;ndash;namespaced=true -o name | xargs -n 1 kubectl get &amp;ndash;show-kind &amp;ndash;ignore-not-found -n rook-ceph&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用kubectl edit crd clusters.ceph.rook.io编辑
Terminating，把finalizers的值删掉，保存&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.codeleading.com/article/5578440677/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.codeleading.com/article/5578440677/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生总结</title>
      <link>https://kurimi1.github.io/post/cloud/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://kurimi1.github.io/post/cloud/</guid>
      <description>&lt;h2 id=&#34;云原生-主流组件&#34;&gt;云原生-主流组件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Grafana&lt;/li&gt;
&lt;li&gt;Elasticsearch + Fluentd + Kibana&lt;/li&gt;
&lt;li&gt;Jaeger(调用链路跟踪)&lt;/li&gt;
&lt;li&gt;Chaos Engineering(混沌工程)-chaosmonkey&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;腾讯文章&#34;&gt;腾讯文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649760560&amp;amp;idx=1&amp;amp;sn=0e644916ed8a8bdcd65e903fb3498e74&amp;amp;chksm=beccb04b89bb395d4461f67cb319293dccc5c51047892bb7692d93e761d67a652eacd83ac62d&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0616zu8zL3I5bYdVMbtposEu&amp;amp;sharer_sharetime=1623846102060&amp;amp;sharer_shareid=8a8cb9782b5089d1e0f623249d1fd45c#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649760560&amp;idx=1&amp;sn=0e644916ed8a8bdcd65e903fb3498e74&amp;chksm=beccb04b89bb395d4461f67cb319293dccc5c51047892bb7692d93e761d67a652eacd83ac62d&amp;mpshare=1&amp;scene=23&amp;srcid=0616zu8zL3I5bYdVMbtposEu&amp;sharer_sharetime=1623846102060&amp;sharer_shareid=8a8cb9782b5089d1e0f623249d1fd45c#rd&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
