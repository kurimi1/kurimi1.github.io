<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>deploy | Donald Blog</title>
    <link>https://kurimi1.github.io/tag/deploy/</link>
      <atom:link href="https://kurimi1.github.io/tag/deploy/index.xml" rel="self" type="application/rss+xml" />
    <description>deploy</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><lastBuildDate>Wed, 08 Jun 2022 03:44:18 +0000</lastBuildDate>
    <image>
      <url>https://kurimi1.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url>
      <title>deploy</title>
      <link>https://kurimi1.github.io/tag/deploy/</link>
    </image>
    
    <item>
      <title>Pack Backend Frontend in a Docker</title>
      <link>https://kurimi1.github.io/post/pack-backend-frontend-in-a-docker/</link>
      <pubDate>Wed, 08 Jun 2022 03:44:18 +0000</pubDate>
      <guid>https://kurimi1.github.io/post/pack-backend-frontend-in-a-docker/</guid>
      <description>&lt;p&gt;前后端分离是主流，go也可以通过template进行服务器渲染前端，但采用主流的前端框架vue，react，flutter等有丰富的UI，且前端可以直接做CDN等优势。本文总结当一个小项目前后端分离时仅通过一个容器启动的方法。&lt;/p&gt;
&lt;h3 id=&#34;通过nginx部署前端反代到后端api&#34;&gt;通过nginx部署前端，反代到后端api&lt;/h3&gt;
&lt;p&gt;这种方式相当于一个容器里起了nginx和后端2个服务。后端需要监听端口，nginx通过访问本地端口来连接后端。&lt;/p&gt;
&lt;h3 id=&#34;后端路由到前端的静态资源前端实现反代调用后端api&#34;&gt;后端路由到前端的静态资源，前端实现反代调用后端api&lt;/h3&gt;
&lt;p&gt;后端路由设置静态文件目录，根目录/301到静态目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.Static(&amp;quot;/static&amp;quot;, &amp;quot;./static&amp;quot;)
r.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) {
  c.Redirect(http.StatusMovedPermanently, &amp;quot;/static/&amp;quot;)
  return
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前端axios设置base_url&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL, // api base_url
  timeout: 6000 // 请求超时时间
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;将前端静态资源嵌入到go二进制当中&#34;&gt;将前端静态资源嵌入到go二进制当中&lt;/h3&gt;
&lt;p&gt;这样做不需要复制静态文件，直接运行二进制即可。&lt;code&gt;阅读drone源码发现的&lt;/code&gt;，前端是单独放在另一个仓库中的&lt;a href=&#34;https://github.com/drone/drone-ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/drone/drone-ui&lt;/a&gt;，这里的dist目录里面有两个文件dist.go和dist_gen.go。
其中dist.go的“代码”只有短短的两行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package dist

//go:generate togo http -package dist -output dist_gen.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里就要介绍一下go generate命令了。&lt;/p&gt;
&lt;h4 id=&#34;go-generate是什么&#34;&gt;go generate是什么？&lt;/h4&gt;
&lt;p&gt;go generate 是自 Go 1.4 版本后加入的一个命令，当运行此命令时，它将扫描与当前包相关的源代码文件，找出文件中所有包含//go:generate的特殊注释，并将该注释后面的内容当做 shell 执行。
虽说是可以执行任意命令，但它往往被用作自动生成代码。为了避免自动生成的代码之后被人为修改，往往还会在生成的代码前面加上// Code generated by xxxx; DO NOT EDIT.这样的提示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意，//go:generate并不会在go build或go run时执行。只能单独使用go generate执行。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其实 Go 里面还有很多类似//go:xxx这样的注释。像//go:noinline //go:nosplit //go:norace 这些，大多都是控制 Go 编译器的一些命令。&lt;/p&gt;
&lt;p&gt;回到 Drone，这里的go:generate togo http -package dist -output dist_gen.go后面的命令是使用了 Drone 作者自己开发的一个小工具togo。&amp;laquo;&lt;a href=&#34;https://github.com/bradrydzewski/tog%3e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/bradrydzewski/tog&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它可以将 HTML、SQL、JSON 等静态文件转换成 Go 文件。使我们可以直接在项目的 Go 源码中调用这些文件。togo就是个 CLI 程序，源码不多；大概看了下，基本流程就是将静态文件的内容进行简单的处理后（比如转义掉反引号）然后使用 Go 自带的模板语言template包将静态文件内容以及文件信息插入到事先写好的 Go 代码模板中。&lt;/p&gt;
&lt;h4 id=&#34;将dist_gengo引入到项目中&#34;&gt;将dist_gen.go引入到项目中&lt;/h4&gt;
&lt;p&gt;Build the app and run go generate&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;npm run build
# change to the dist directory
cd dist
# run go generate
GO111MODULE=off go generate ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will update the &lt;code&gt;dist/dist_gen.go&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;既分离了前后端项目的源代码，又通过包的方式使得前端和后端能很好的结合，妙啊！&lt;/p&gt;
&lt;p&gt;同样是&lt;code&gt;后端路由输出静态文件&lt;/code&gt;，只不过静态文件在go代码中，一起编译成二进制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func HandleIndex(host string, session core.Session, license core.LicenseService) http.HandlerFunc {
	return func(rw http.ResponseWriter, r *http.Request) {
    user, _ := session.Get(r)
		if user == nil &amp;amp;&amp;amp; r.URL.Path == &amp;quot;/&amp;quot; {
			http.Redirect(rw, r, &amp;quot;/welcome&amp;quot;, 303)
			return
		}

		out := dist.MustLookup(&amp;quot;/index.html&amp;quot;)
		ctx := r.Context()

		if ok, _ := license.Exceeded(ctx); ok {
			out = bytes.Replace(out, head, exceeded, -1)
		} else if license.Expired(ctx) {
			out = bytes.Replace(out, head, expired, -1)
		}
		rw.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html; charset=UTF-8&amp;quot;)
		rw.Write(out)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html会引用static下的js，css等因此要设置路由链接嵌入的静态文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	h := http.FileServer(dist.New())
	h = setupCache(h)
	r.Handle(&amp;quot;/favicon.png&amp;quot;, h)
	r.Handle(&amp;quot;/manifest.json&amp;quot;, h)
	r.Handle(&amp;quot;/asset-manifest.json&amp;quot;, h)
	r.Handle(&amp;quot;/static/*filepath&amp;quot;, h)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里再提一下上面两个命令中的./..这个用法。它可以遍历包括当前文件夹在内的所有子文件夹。
起初看到这个还以为是操作系统的特性，但谷歌搜了半天没搜到。最后还是在 Go 的源码文档里看到了对此的解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &amp;ldquo;go list&amp;rdquo; subcommand lists the import paths corresponding to its arguments, and the pattern &amp;ldquo;./&amp;hellip;&amp;rdquo; means start in the current directory (&amp;quot;./&amp;quot;) and find all packages below that directory (&amp;quot;&amp;hellip;&amp;quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;最后提一下将静态文件嵌入go二进制的工具很多&#34;&gt;最后提一下将静态文件嵌入go二进制的工具很多&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;togo已经不再维护&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一些开源的项目很久以前就开始做这方面的工作，比如gobuffalo/packr、markbates/pkger、rakyll/statik、knadh/stuffbin等等，但是不管怎么说这些都是第三方提供的功能，如果Go官方能内建支持就好了。2019末一个提案被提出issue#35950,期望Go官方编译器支持嵌入静态文件。后来Russ Cox专门写了一个设计文档Go command support for embedded static assets, 并最终实现了它。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
